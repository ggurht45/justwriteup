goals
working on background section. explaining about javafx:
	-	talk about javafx scenegraph, when root node is discussed.  --done
	-	talk about launch and start methods --done
	-	think about what to write next. --done	
	-	take pic of stagesceneroot, put it in figures. --done
	-	push --done
	- 	put line numbers on code sample --done, but looks too left. 
	-	add figure label to code sample --works. so happy.
	-	work on writing on computer rather than online. faster feedback. --nah. doesnt work
	-	put stuff on overleaf. --working on it. seem to have a method that works now. 
	-	what is fxml. --done 
	-	give a very short example of fxml--done
	-	make a pic of what the both examples should show. --nah will leave this for now. actually will do it. how long can it take
	-	discuss fxmlloader.--done  what? why? when do i use it?  --done. 
	-	write about fxml. give a short example and explain it. --done
	-	write about fxmlloader. --done
	-	explain how "" its used in this project, especially static vs instance method.--done
	-	explain why it is important to get a handle on the controller object. --done
	-	fix bug about verb. latex has the weirdest bugs. something about main having problem at 313. and next not getting closed. but actual problem was verbaitum not getting closed i think. --done
	-	fix comments --done
	- 	discuss scenebuilder. --done
	-	discuss libraries jfoenix. just discuss it for now. --done
	-	start discuss leapmotion. --done
	-	give a small example of lm --done
	-	look at zifos for inspiration. dont have to write a lot. --done	
	
	
	-	fix spelling mistakes in draft 1. 
--------------------------------------------------------------






	
working on chapter 2, ui hand model 	
	-	work hard. 
		- good job. you worked hard. keep working hard. it will all pay off ^^
		- took way too long break from 9:20-11:20. 
		- good job. started workign hard again. recite for encouragement. 
		- 
		- started working on writing concurrency stuff. just began but still a very big milestone. good job! ^^
		- keep up the good work. it will all pay off. 
	'	
	
	- fix spelling and code samples. --done
	- fix figure names and referencing. --done
	
	- explain that javafx scene graph, the ui component of a javafx appliction, is not thread safe. 	
	- '' to modify it, it can only be accessed and updated via the main ui thread. (see below)
	- explain what is JavaFX Application thread. 
	
	- read for understanding: make notes. exposition. 
	
	
	- http://docs.oracle.com/javafx/2/threads/jfxpub-threads.htm
		- write notes here
		- quick read. till 45. 
		
		- paragraph: why use javafx.current package. 
		
		- key is keeping the ui responsive. --> so user doesnt get angry. (first paragraph). 
		- to achieve '' you delegate time-consuming tasks to background threads. 
		- scenegraph/ui is not threadsafe can be only modified via javafx application thread (jat)
		- implementing long tasks on ^ makes it unresponsive the ui i mean. 
		- best practice is to put long time taking tasks on background threads and let the main jat *** proccess user events** 
		
		
		- implementing a background worker by creating or implementing the runnable interface can be rather tricky to get just right and often leads to unintended consequences such as deadlock where the threads are stuck waiting forevever and race conditions in which critical data can be modified relatively simultaneously by two competing threads. 
		
		- therefore the recomended approach is to use the javafx apis provided in the ... concurrent package. the classes in this package take care of providing the best implementations to interact with the UI and to ensure the interaction happens on the correct thread. 
	
		- java is so nice. lol. instead of rolling your own, its better to go to the shop. 
		
		- new paragraph: overview of concurrent package. 
		- java already provides a whole set of concurreny libraries in the java.util.concurrent package. what the javafx.concurrent package does it it leverages these existing apis and takes into account the javafx application thread and user interface contraints faced by gui developers. it optimeizes the concurrecy libraries to be more suitable for gui development. 
		
		- task, just like service implements the worker interface.<- worker interface provides useful apis to help set up background worker thread, and allowing communication between that thread and jat. 
		
		- so as has been mentioned, java already has concurrent libraries defined in util package. however these are not that useful for gui application because these type of application require "obervable" implementation of the common data collection types such as an ObservableList and ObservableHashmap. They difference between these observable abstract data types and traditional ones such as arraylist is that these are automatically synchronization with two way data binding between them and view components shown on screen. there is less manual work needed to be done on the programmar's part. the older adt's do not have these functionalities so they are not suited to be used when building ui's. 
		
		-direct quote. 
		 As a result, it is quite difficult to update, add, or remove objects from the model list and at the same time reflect changes in the view component. To overcome this problem, JavaFX uses observable interfaces and their implementation, such as ObserverList<E>.
		 
		- so now that we know the importance of the observable interfaces in java, the javafx concurrent package provides classes such as task which is a fully obervable implementation of the corresponding java.util.concurrent.futureTask class. therefore this task class is very much suited for implementing asychronous tasks in javafx that can handle user interaction and respond to events exectued on the ui. This ability to handle user events is further displayed by the fact that the task class implements the eventTarget interface. 

		-task class ---- more in depth:
		Creating a custom task requires extending the task class and implementing the call() method. the call method is should contain code that only changes states which are safe to be modified from the background thread. Therefore the call method cannot change the active scene graph nodes displayed on the screen as that may cause runtime exceptions. Nevertheless, since Task is designed to be used in GUI applications, it does have the ability to update observable data properties, change notifications for errors and cancellation of tasks, and respond to event being fired.
		
		It is important to note that the Task class, since it implements the java.utils.concurrent.FutureTask class, fits into the traditional Java concurrency model also. The FutureTask class implements the Runnable interface, one of the key requirements for being able to be executed as a thread. Therefore, the Tasks can also can be used within the Java concurrency Executor API and also can be passed to a thread as a parameter.

	
		------show how task is used in our application. background is done now. 
		In this 
		
-----------------
new quick goals. 
-read more about platform.runlater.
-learn how its used in our code. 
-write and explain in the paper. 

--anything i write that i learned while doing this project is fair game and good stuff to write expositionally about.

-re-read my madman words and clean them up. spell check. carpenter. 


-----------------		
		
	- https://stackoverflow.com/questions/15160410/usage-of-javafx-platform-runlater-and-access-to-ui-from-a-different-thread
		- write notes here
	
		
	- https://stackoverflow.com/questions/19755031/how-javafx-application-thread-works
		- write notes here		
		
		
	
	- http://docs.oracle.com/javafx/2/api/javafx/concurrent/Task.html
		-WAY TOO DENSE... SHEESH!
	
	- http://www.developer.com/java/data/understanding-java-observable-and-javafx-observable.html (observable stuff in java)
		-important paragraph:
		Before JavaFX, Swing developers relied on ArrayList to contain a list of objects and subsequently display them in a list-like UI control, such as JList. But, ArrayList is too generic and was not built keeping in mind the requirement of synchronization when associated with a view component. As a result, it is quite difficult to update, add, or remove objects from the model list and at the same time reflect changes in the view component. To overcome this problem, JavaFX uses observable interfaces and their implementation, such as ObserverList<E>.
	
	
	
	
	'
	
	
	
	
	
	
	
	
	
	- read the docs on javafx.concurrent and make notes about what to write about. 
	- also glance at the code to see how you want to explain it. maybe will need to do some debugging. but first read and get working on paragraph. 	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	- write one sentence at a time. think about what the sentence should be. write out what you should be expressing (as if you are trying to explain it to a friend). seeing this in words will make it more concrete and help you write what you need to. 
	- think about what questions you are trying to answer. write them in the paragraph to help you begin
	
	- can take out driving questions later. 

	
	
	
	
	- 	snchronized. platform.runlater. print statements to determine which methods actually run. 		
	- why is synchronized important. what does it mean in the program. 
	- what is run later? is it a thread? does it start multiple threads? 
	- explain how the program is running several threads in conjuction. 
	- for example, the one listening on user input, the one processing data from lm
	

	
	-	update bibliography on overleaf. 
--------------------------------------------------------------
	

	
	
	
	
	
	
	
	
	
	
%----------------------------------- Limitations of Sensor and Documentation (put this when talking about rotation and coordinate systems chapter)
\subsection{Limitations of Sensor and Documentation}
--occulusion
--discontinuation of publishing v2 apps
--sensor resetting by opening palm
--not enough documentation for linux/ubuntu. 
--talk about the right handed coordinate system of leap motion. (do this in the section on coordinate systems)




------Appendix A:
setting up project in intellij ide. 
--discuss how to set the library path for compiling and running jar. and program. 
talk about sdk and how its different from just installing leap motion. <- runs a process. etc. to be able to receive info from that process we need 
native lib. 
--read the page on lm website and summarize
