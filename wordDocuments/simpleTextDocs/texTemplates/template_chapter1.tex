% Chapter Template

\chapter{Background}

\label{Chapter1} 

\begin{comment}
-------------------------------------------------
%								Chapter layout
2. Background
	a. Leap Motion (v2)
		i. Java API
		ii. Native Libraries
		iii. Limitations of Sensor and Documentation
	b. JavaFx
		i. Java vs FXML
		ii. SceneBuilder
		iii. Jfoenix
		iv. ControlsFx
	c. IntelliJ IDE
		i. Unix Style Terminal on Windows
-------------------------------------------------
\end{comment}



%------------------------------------------------
%	SECTION 1 Leap Motion (v2)
%------------------------------------------------

\section{Leap Motion (v2)}
--introduction to the sensor. when it was made. company behind it. what its used for. price



%----------------------------------- Leap Motion Java API
\subsection{Java API}
hand class, fingers bones. vector. 



%----------------------------------- Native Libraries
\subsection{Native Libraries}
--read the page on lm website and summarize




%----------------------------------- Limitations of Sensor and Documentation
\subsection{Limitations of Sensor and Documentation}
--occulusion
--discontinuation of publishing v2 apps
--sensor resetting by opening palm
--not enough documentation for linux/ubuntu. 




%------------------------------------------------
%	SECTION 2 JavaFX
%------------------------------------------------

\section{JavaFx}

JavaFX is a framework provided by Oracle Corporation that is intended to replace the Swing framework as the standard GUI library for developing desktop applications that can be run on any platform that supports Java. Since the JavaFX 2.0 release, JavaFX application can be written in pure Java code. Before that release, applications written using JavaFX libraries had to be written in Java FX Script, a scripting language designed and used specifically for the purpose of creating GUI applications with JavaFX. This project uses the latest version of this framework, JavaFX 8, which also added support for 3D graphics and sensor support. 


%----------------------------------- Java vs FXML
\subsection{Java vs FXML}

When writing a JavaFX application, there are two very different approaches that can be used to create the actual user interface (UI) for the application. These are pure Java code and FXML. A brief introduction both of these approaches will be given below. 

The pure Java approach constructs the JavaFX application scene graph procedurally through code. Below is a simple “Hello World” program that shows a quick example of this approach in action.

\begin{figure}[th]
\centering
\begin{lstlisting}
public class HelloWorld extends Application {
public static void main(String[] args) {
	launch(args);
}

@Override
public void start(Stage primaryStage) {
	primaryStage.setTitle("Hello World!");
	Button btn = new Button();
	btn.setText("Say 'Hello World'");
	btn.setOnAction(new EventHandler<ActionEvent>() {
		@Override
		public void handle(ActionEvent event) {
			System.out.println("Hello World!");
		}
	});
	
	StackPane root = new StackPane();
	root.getChildren().add(btn);
	primaryStage.setScene(new Scene(root, 300, 250));
	primaryStage.show();
}
}
\end{lstlisting}
\caption{A simple hello world program using JavaFX written using just Java code.}
\label{fig:helloWorldJavaFX1}
\end{figure}

This small snippet of code contains the overall structure and all of the basic components of a JavaFX application. The first point to note is that the main class which will run the JavaFX application must extend from the abstract base class called javafx.application.Application and implement is abstract start() method. The start() method serves as the main entry point for all JavaFX applications. In the application’s main() method, which is common to all Java applications, a call must be made to the launch() method which is a method defined in the base Application JavaFX class that actually launches the application in doing so makes a call to the start() method. 

The start() method receives a parameter of type Stage which serves as the primary Stage object for the application. Stage is the top-level user interface container object used by JavaFX to house the whole application. In colloquial terms it can be considered to be the “window” object of the whole application. The Stage object is has a setScene() method which requires a Scene object to be passed in. Scene class is the container of current content being displayed by the application. An application can have multiple scenes which display different pages of the the application. In JavaFX, the actual UI components, such as the StackPane layout Node shown in the simple HelloWorld example above, must be added to the Scene object in order for them to be displayed. This relationship between the Stage, Scene and “root” Node components of a JavaFX application is depicted in Figure \ref{fig:stageSceneRoot}.
\begin{figure}[th]
\centering
\includegraphics[scale=0.5]{Figures/stageSceneRoot.JPG}
\caption{The layout components of every JavaFX application.}
\label{fig:stageSceneRoot}
\end{figure}


The UI components all extend from a parent Node class. One of the improvements that JavaFX brought in regards to its predecessor Swing, is that it represents the entire content of the scene as a tree. More specifically, all of the nodes displayed in a Scene container object must extend from a root level node and be part of the hierarchical scene graph of nodes. Figure \ref{fig:javafxSceneGraph}  displays an example of the JavaFX scene graph. 
\begin{figure}[th]
\centering
\includegraphics[scale=0.5]{Figures/javafx_scenegraph.JPG}
\caption{The Scene Graph architectural model for UI components in JavaFX applications.}
\label{fig:javafxSceneGraph}
\end{figure}


Now that the pure Java code approach of writing JavaFX applications has been introduced, let us discuss the other approach to writing JavaFX applications; FXML. FXML is a XML-based language created by Oracle Corporation for the purpose of making it easier to define the UI of a JavaFX application. While the pure Java code approach is a much more imperetive and procedural way to write JavFX applications, FXML is a more declartive way. It resembles HTML and can also reference a controller java class which can access and modify the UI elements defined in the FXML file. Figure \ref{fig:simpleFXML} shows a very simple FXML file that creates a VBox layout and adds a button to it. This FXML file also has a Java controller class attached to it which is called MyController.java and shown in Figure \ref{fig:simpleController}

\begin{figure}[th]
\centering
\begin{lstlisting}
<?xml version="1.0" encoding="UTF-8"?>
<?language JavaScript?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<VBox fx:id="myView" layoutX="10.0" layoutY="10.0" xmlns:fx="http://javafx.com/fxml/1" xmlns="http://javafx.com/javafx/2.2" fx:controller="MyController">
  <children>
    <Button fx:id="okBtn" alignment="CENTER_RIGHT" contentDisplay="CENTER" mnemonicParsing="false" onAction="#printHelloWorld" text="Say Hello World" textAlignment="CENTER" />
  </children>
</VBox>
\end{lstlisting}
\caption{A FXML file defining a simple layout and referencing a controller java class.}
\label{fig:simpleFXML}
\end{figure}


\begin{figure}[th]
\centering
\begin{lstlisting}
public class MyController 
{
	@FXML
	private void initialize() 
	{
	// this method runs first after all the UI components have been loaded and bound.
	}
	
	@FXML
	private void printHelloWorld() 
	{
		System.out.println("hello world!");
	}
}
\end{lstlisting}
\caption{A controller for the FXML file. The "FXML" annotation in is used to bind certain elements to java objects in the class.}
\label{fig:simpleController}
\end{figure}

The result from both of these HelloWorld examples will be as showing in Figure \ref{fig:helloWorldResult}. The large difference between these two approaches makes it difficult to combine them effectively, but it is possible to use them in conjunction with each other. This project takes such an approach. For the UI construcion of the the user's hand model, the pure java code approach was taken. However, for the interface of the application the table construction showing all of the collected data, the FXML approach was taken. 

\begin{figure}[th]
\centering
\includegraphics[scale=0.5]{Figures/helloWorldResult.JPG}
\caption{The output of the simple HelloWorld application.}
\label{fig:helloWorldResult}
\end{figure}


One of the things that should be discussed is how communication can happen between different components of the application when FXML files are being used. There is a special class called FXMLLoader which is used to load FXML files and return the object graph of UI components these files contain. The FXMLLoader contains two \verb {load()} methods one of which is a static class method and the other is an instance method. The important difference between these two methods is that that instance \verb {load()} method can be used to gain access to the controller for the FXML class being loaded. Gaining access to the controller object for an FXML file in other other parts of an application is very important if one has to pass paramters into the view to change the interface. Figure \ref{fig:fxmlLoaderCode} this key difference between the two methods. 

\begin{figure}[th]
\centering
\begin{lstlisting}
// The approach uses the static "load" method. Not recommended
Parent root = FXMLLoader.load(getClass().getResource("fxml_example.fxml"));
 
//This approach allows one to access the controller. 
//create instance of FXMLLoader
FXMLLoader loader = new FXMLLoader(getClass().getResource("fxml_example.fxml"));
//get the controller
MyController controller = loader.<MyController>getController();
//initialize controller with custom parameters
controller.initData(data);
//object graph root handle
Parent root = (Parent) loader.load();
\end{lstlisting}
\caption{Retrieving a reference to the controller object for a loaded FXML file.}
\label{fig:fxmlLoaderCode}
\end{figure}







%----------------------------------- SceneBuilder
\subsection{Scene Builder}
Scene Builder is a software that can be installed on one's computer to help design the UI and layout of a JavaFX application. It allows the user to drag and drop components from the library of available components to the central work area where they can be modified and their properties tweaked. This software is a free and open source tool that used to be developed by Oracle Corporation, but is now backed by Gluon. The easy to use drag and drop functionality of the Scenebuilder allows for easy design and rapid iteration. The associated FXML code with UI created by Scene Builder can be incorporated into the JavaFX application. Using Scene Builder code bindings can also be placed on certain UI components to allow for them to execute specific logic that can be defined in the controller class of the FXML file. Figure \ref{fig:sceneBuilderWindow} shows the main layout of the Scene Builder application. There are four main panels of information that have been labelled appropriately in the figure. These are: the Library panel, which contains all of the UI components available for use; the Document panel, which shows the object graph hierarchy of the current scene being built; the Content panel, which shows the work area for user interaction; and finally the Inspector panel, which shows the various properties and layout parameters which can be modified for the currently selected UI component, as well as the various code bindings that can be placed on it. 

\begin{figure}[th]
\centering
\includegraphics[scale=0.35]{Figures/sceneBuilderWindow.JPG}
\caption{This shows the different areas of interest in the Scene Builder software.}
\label{fig:sceneBuilderWindow}
\end{figure}




%----------------------------------- Jfoenix
\subsection{Jfoenix Library}

what is it? material design. short explaination of how it can be incorporated into scenebuilder and project. intellij maven. etc. 















